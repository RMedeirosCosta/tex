\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage[latin1]{inputenc}  

\graphicspath{{img/}}
     
\sloppy

\title{Visualização de Grandes Quantidades de Dados em Grafo\\ Uma Abordagem para Limitações Conhecidas}
\author{Ricardo Medeiros da Costa Junior\inst{1}, Carlos Silla Junior\inst{1}}
\address{Universidade Tecnológica Federal do Paraná - (UTFPR)\\
\email{ricardo.medeiros.costa@gmail.com, emailDoProfessor@dominio.com}
}

\begin{document} 

\maketitle

\begin{abstract}
  Large graph visualization have been used for many knowledge areas. However, for big amount of data, there are many hardware limitations. To avoid this problems, it was showed an attempt which it was used a graph database that aims export subset of the whole of data, providing a way to show it on the visualization software. This attempt was successful for the cases which there are possibilities to show the data in smallers fragments.
\end{abstract}
     
\begin{resumo}
 Visualização de grandes quantidades de dados em grafos são utilizadas em importantes áreas do conhecimento. Todavia, quando se trata de visualização de massiva quantidade de dados, limitações de hardware podem prejudicar a exibição e o entendimento da análise. Para contornar esse problema é demonstrado uma abordagem no qual é utilizado um banco de dados em grafos que tem por objetivo gerar subconjuntos dos dados permitindo a apresentação do grafo por meio da aplicação de visualização. Essa abordagem mostrou-se eficiente para casos em que há possibilidade de visualizar os dados separadamente em fragmentos menores.
\end{resumo}

\section{Introdução} 

A Teoria dos Grafos, desde que foi inventada no século XVIII por Leonhard Euler, vem contribuindo para o desenvolvimento da humanidade (Wikipédia). De acordo com Neo4jBook, a Teoria dos Grafos é aplicada em várias áreas da Ciência da Computação, tais como: desenvolvimento de chips, gerenciamento de redes, sitemas de recomendações e modelagem UML (Unified Modeling Language) \footnote{Uma linguagem de modelagem na área da Engenharia de Software que tem por objetivo prover um padrão de visualização do design de um sistema.} Além disso, grafos são utilizados para resolver problemas de roteamento, lista de todas as rotas disponíveis entre cidades, encontrar o melhor caminho entre localizações, verificar distância, velocidade permitida entre outros problemas. Outro exemplo de aplicação da Teoria dos Grafos são os algoritimos de busca na web. Estes algoritimos verificam a importância de um site pela quantidade de links direcionados para este site. Goldeberg (ano) afirma  que redes de relacionamentos estruturadas em grafos são aplicadas em comunidades virtuais, por exemplo: Facebook, MySpace e Linkedin.

A visualização dessas redes de relacionamento são instrumentos importantes para pesquisadores entenderem massiva quantidade de dados (Japoneses). Herman (ano) destaca algumas áres do conhecimento que a visualização de dados em grafos tem aplicabilidade. A hierarquia de um sistema de arquivos pode ser representada como uma árvore, que por sua vez é um grafo. Esse tipo de visualização de dados também é utilizado na biologia e na química, por meio de mapas moleculares, padrões de interação entre proteínas, árvores filogenéticas e mapas genéticos. Soma-se a isso, a visualização em grafos facilita o reconhecimento de padrões (Neo4jbook).

No entanto, a visualização de dados em grafos enfrenta alguns obstáculos. Se a quantidade de elementos for extensa, a performance da execução pode ser comprometida e os elementos visuais podem exceder os limites do dispositivo de apresentação (Herman). Os Japoneses ressaltam essas dificuldades e complementam que a insuficiência de RAM (Random-access memory) pode ocasionar em não exibição da rede de relacionamentos. Todavia, estes pesquisadores sugerem que reduzir os dados em porções menores que são relevantes para análise pode contornar estes problemas.

Partindo desta hipótese, o objetivo dessa pesquisa é empregar essa abordagem para exibir volumosas quantidades de dados usando uma tecnologia de armazenamento que possa armazenar os dados estruturados em grafos e fornecer meios práticos para gerar esses fragmentos de dados que poderão ser visualizados em uma ferramenta de visualização de dados em grafos.

Esse artigo está organizado da seguinte forma: na próxima seção será exibido o conjunto de dados utilizado na pesquisa, na terceira seção será demonstrado as tecnologias necessárias para alcançar o objetivo e o porquê de sua utilização, na quarta seção é descrito o desenvolvimento da pesquisa e o por fim a conclusão, com os resultados obtidos.

\section{Conjunto de Dados} \label{sec:firstpage}

Para realizar este estudo de caso, utilizou-se um conjunto de dados chamado STRING (\textit{Search Tool for the Retrieval of Interacting Genes/Proteins}) \footnote{Disponível em http://string-db.org/}. STRING é um banco de dados sobre interações entre proteínas. O banco de dados atualmente possui 9.643.763 proteínas catalogadas vindas de 2.031 organismos. Para realizar o \textit{download} completo deste cojunto de dados é necessário ter uma licença de acadêmico ou efetuar o \textit{download} dos dados em formato de texto, cujo estão estruturados na forma de linhas e colunas.

O STRING foi escolhido pelos seguintes fatores: primeiramente a sua natureza de interações entre proteínas assemelha-se com a teoria dos grafos em que as proteínas são os vértices e as interações nomeadas com determinados valores são arestas ponderadas; outro fator importante foi que os dados baixados estão sob a \textit{ Creative Commons Attribution-Noncommercial-Share Alike 3.0 License}\footnote{Disponível para visualização em http://creativecommons.org/licenses/by-nc-sa/3.0/} no qual permite compartilhamento e adaptação do produto, contanto que não seja usado para fins comerciais; e por último, como foi supracitado, os dados estão estruturados em matrizes dentro do arquivo texto, facilitando a integração com tecnologias de armazenamento de dados.
        
Não foi o utilizado o banco de dados completo, apenas os dados de um organismo chamado \textit{Macaca Mulatta}. Não obstante, a quantidade de interações entre proteínas desse organismo satisfaz a condição para este estudo de caso, pois são mais de 9.000.000 de interações catalogadas nesse arquivo. O arquivo é similar ao da Figura 1, porém na Figura 1 é mostrado apenas as primeiras 20 linhas do arquivo com objetivo de familiarizar o leitor com a estrutura do arquivo.
	
\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{1}
\caption{Estrutura do Arquivo Texto}
\label{fig:figure1}
\end{figure}

Nota-se que as duas primeiras colunas são referentes as duas proteínas que interagem entre si e as demais representam a associação entre essas proteínas, que são mensuráveis de acordo com o valor informado em cada célula. Caso o valor da célula seja zero, as proteínas não possuem a relação daquela coluna. É possível obter a lista detalhada de cada uma das colunas em http://string-db.org/newstring_cgi/show_info_page.pl?UserId=PP0x_BdRDgY6&sessionId=3AoJ_NBYmbPT .
	
\section{Tecnologias}

As tecnologias utilizadas para alcançar o objetivo da pesquisa são: um banco de dados em grafos que possua funcionalidades de importar o arquivo contendo os dados das interações entre proteínas do organismo \textit{Macaca Mulatta} e exportar os dados de forma completa ou parcial; e uma ferramenta na qual seja possível visualizar os dados exportados de acordo com o formato gerado pelo banco de dados.

\subsection{Banco de dados: Neo4j}

A ferramenta selecionada para armazenar os dados em grafos é o Neo4j.\footnote{Disponível em http://neo4j.com/}. O Neo4j é um projeto de código aberto que é mantido pela empresa Neo Technology. Esta ferramenta possui duas versões: a \textif{Community} e a \textit{Enterprise}. A versão \textit{Enterprise} possui alguns recursos que a versão \textit{Community} não possui, contudo para o propósito desse trabalho os recursos da versão \textit{Community} são suficientes.

O Neo4j possui uma funcionalidade para importar determinados tipos de dados, incluindo CSV (\textit{Comma Separated Value}) \footnote{Um arquivo no qual os dados são estruturados em formato de tabela e os valores são separados por vírgulas ou qualquer outro caracter de separação} satisfazendo a primeira necessidade para a tecnologia de armazenamento dos dados. Para se realizar consultas no Neo4j é utilizado a linguagem descritiva Cypher, cuja é parecida com o SQL. Essa linguagem será responsável por filtrar os resultados, reduzindo o conjunto de dados em uma porção menor que será exibida na ferramenta de visualização. Entretanto, o Neo4j \footnote{Pelo menos até a versão 2.3 utilizada nessa pesquisa} não possui a funcionalidade de exportação dos dados em um formato conhecido pelas ferramentas de visualização de forma nativa. Para contornar esse problema, foi utilizado o programa Neo4j-Shell, disponível em https://github.com/jexp/neo4j-shell-tools. Com essa ferramenta é possível exportar dados realizados por meio de consultas Cypher em vários tipos de formatos, inclusive \textit{Graphml}, um padrão de arquivos de grafos que é lido por vários \textit{softwares} de visualização de grafos, possui informações adicionais para visualização dos dados e contém dois principais objetivos: Simplicidade e Generalização. (Graphml)

Além das três necessidades para atingir o objetivo da pesquisa, o Neo4j possui outros atrativos, tais como: sua versão \textit{Community} está sob a licença GPL (\textit{General Public License}) v3.0 que visa a liberdade para uso do software para qualquer propósito; tem uma comunidade ativa, o que facilita a busca por suporte ou documentação na internet; é multiplataforma, pois foi desenvolvido para rodar sobre a máquina virtual do Java; é escalável, sua performance é otimizada para lidar com muito relacionamentos e é flexível se comparado com outras arquiteturas de banco de dados, porque não é necessário criar um esquema rígido para pmodelar o banco de dados.
          
\subsection{Ferramenta de Visualização: Gephi}
         
Gephi é um dos softwares de código aberto mais populares na área de análise e visualização de grandes redes de relacionametno (Japoneses). Assim como o Neo4j foi desenvolvido em Java, portanto também é multiplataforma. Os três conceitos principais são usabilidade, performance e modularidade. O desenvolvimento do Gephi continua ativo e o código fonte do projeto encontra-se em: https://github.com/gephi/gephi .

Como o Gephi está sob as licenças CDDL-1.0 (\textit{Common Development and Distribution License}) e a GPL v3.0 que permitem a utilização do software de forma gratuita, o emprego do software na pesquisa pode ser realizado sem nenhuma restrição legal. Outra vantagem do Gephi, é que este software usa OpenGL como motor de visualização cujo provê uma performance considerável na exibição do grafo (Japoneses).

Além do mais, são características do Gephi o emprego de algoritimos que estão no estado da arte em desenho de grafos; métricas para mensuração tais como média para caminho mais curto, coeficiente de agrupamento, proximidade, entre outras; soma-se a isso, a customização que é possível ser feita por esta ferramenta, no qual pode-se alterar cores, rótulos, tamanhos baseado em \textif{rankings} de graus, por exemplo. É possível aplicar um algoritimo chamado de \empth{Modularidade} que detecta agrupamentos e aplica cores distintas para esses agrupamentos (gephi).

\section{Desenvolvimento}

Após feito o \textit{download} do arquivo contendo as interações entre as proteínas do organismo \textit{Macaca Mulatta}, necessitou-se alterar a extensão do arquivo de txt para csv, com intuito do importador nativo do Neo4j ler e conseguir persistir os dados no banco de dados recém criado.

O banco de dados Neo4j possui algumas peculiaridades. Cada nó pode ter um ou mais rótulos, que tem por objetivo classificar o nó. Nesta perspectiva, as relações (arestas, na Teoria dos Grafos) possuem os tipos. Tanto os nós, quanto as relações podem ter zero ou várias propriedades, estas que por sua vez tem um nome e um valor. O modelo do banco de dados criado para esse trabalho é simples. Os nós tem um rótulo \emph{Protein} e as relações são do tipo \emph{INTERACTS\_WITH}. Todos os nós tem apenas uma propriedade \emph{name}, cujo consta o nome da proteína que pode ser da coluna \emph{protein1} ou \emph{protein2} do arquivo. As demais colunas do arquivo serão propriedades de cada relação. Para esse banco de dados foi adotado a seguinte convenção: rótulos com a letra inicial em maiúscula e as demais minúsculas, sem espaços entre palavras, prática conhecida como \textit{CamelCase}\footnote{Veja mais em: https://pt.wikipedia.org/wiki/CamelCase}; nome dos tipos das relações com letras em maiúsculas separadas e caso seja necessário um \textit{underline} para separar palavras; e as propriedades todas em minúsculas sem espaços.

Antes de realizar a importação, foi criado um índice para o rótulo \emph{Protein} na propriedade \emph{name}, abordagem recomendada pela documentação oficial do banco de dados caso haja grande quantidade de dados. Após isso, foi feito a importação. Isso foi realizado em dois passos, primeiro foram importados os nós e em seguida foram importados as relações. Na figura 2 é demonstrado as senteças \emph{Cypher}.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{2}
\caption{Senteças Cypher}
\label{fig:figure2}
\end{figure}

A primeira sentença é a criação do índice. A cláusula \emph{using periodic commit 5000} quer dizer que é necessário realizar o commit a cada 5000 objetos carregados na memória, assim como a criação do índice, isso é um prática recomendada pela documentação oficial do Neo4j. Logo em seguida, nota-se \emph{load csv with headers from} que em uma tradução literal significa: "carregar csv com cabecalhos vindo do arquivo". Ao lado consta a localização do arquivo. A cláusula \emph{as} aponta um "apelido" para a linha atual do arquivo, que no caso é a letra \emph{l}. A cláusula \emph{fieldterminator} especifica o separador do arquivo csv, o que no caso é um espaço. A palavra reservada merge age da seguinte forma, caso não tenha uma relação ou nó que atende as condições destacadas na sentença, então esse objeto é criado. Para simplificar, é procurado o nós do tipo \emph{Protein} com a propriedade \emph{name} com valor da célula corrente da coluna \emph{protein1}. Caso encontre, nada é realizado. Se esse nó não for encontrado, então ele é criado com essas características.

A cláusula \emph{match} da terceira senteça tenta combinar o objeto de acordo com as características informadas na sentença. Nesse caso, dois nós, p1 e p2, que possuem rótulo \emph{Protein} com \emph{name} de acordo com a célula da coluna \emph{protein1} e \emph{protein2}, respectivamente. O formato ()-[]-() serve para especificar a relação de um nó, com outro nó. Os parênteses representam os nós e os colchetes a relação. A letra \empth{r} é utilizada com um "apelido" assim com a letra \emph{l} foi usada anteriormente. O \empth{set} nessa sentença, age de forma similar que ao \emph{merge}, mas ao contrário do \emph{merge} estas cláusulas são para proriedades. O resto da sentença especifica que é criado uma propriedade na relação para cada coluna remanescente na linha, com o valor de cada célula convertida para elementos do conjunto dos reais. Após execução da última sentença, é possível vizualizar os dados físicos do banco de dados, como: tamanho total do banco, quantidade de nós, propriedades, relaçoes e tipos de relações inseridas e outras informações. Essas informações podem ser vistas na Figura 3.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{3}
\caption{Informações sobre o banco de dados}
\label{fig:figure3}
\end{figure}

Nota-se que o banco de dados possue 19643 nós e 9.075.028 relações.

Após importar o banco e constatar que os dados foram importados com sucesso, exportou-se todos os dados para o formato \textit{Graphml}. Para executar essa ação, foi necessário executar o comando que consta na Figura 4.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{4}
\caption{Exportação completa do banco de dados}
\label{fig:figure4}
\end{figure}

Tentou-se abrir o arquivo \emph{Graphml} recém exportado no Gephi, porém o problema de visualização de dados com quantidade limitada de memória RAM surge e a tentativa fracassa. Na Figura 5 é demonstrada o alerta de falta de memória enviado pelo \emph{software}.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{5}
\caption{Alerta de falta de RAM do Gephii}
\label{fig:figure5}
\end{figure}

Mesmo acatando a sugestão de aumento de memória mostrado no alerta e reiniciando a aplicação, não foi possível visualizar o grafo. Esta tentiva foi realizada em um computador que possui aproximadamente 8 \emph{Gigabytes} de RAM. Não obstante, outros testes foram realizados em computadores com aproximadamente 16 e 32 \emph{Gigabytes}, ambos com insucesso. Nas poucas vezes em que foram possíveis abrir o arquivo no computador de 16 GB, a performance da exibição demonstrou-se absurdamente instatisfatória acarretando em uma péssima experiência do usuário. No outro computador, a importação foi realizada com ligeira facilidade e fez-se possível a visualização sem pormenores, contudo, dependendo do operação que fosse realizada, tal como aplicar o algoritimo de modularização, a aplicação encerrava-se inesperadamente.

Como a visualização completa do banco de dados ou não foi possível, ou fez-se com desempenho instatisfatório, partiu-se para abordagem de visualização com porções menores.

\subsection{Visualizando Porções Menores}

A exportação do conjunto de dados em porções menores é semelhante a exportação do banco completo que foi demonstrado na Figura 4, a única diferença é a inclusão da sentença \empth{Cypher} no final do comando. O(s) resultado(s) da consulta serão exportados para o arquivo \emph{Graphml}. Como não é possível determinar quais tipos de porções de dados serão relevantes para análise sem um especialista do domínio dos dados, pressupõe-se que uma amostra de 10\% do conjunto universo seria de interesse para análise. Desta forma, a consulta \emph{Cypher} no final do comando foi: \emph{match(p1)-[r]-(p2) return p1, r, p2 limit 907503;}.

Depois de exportado a amostra, abriu-se o arquivo no Gephi. Ao contrário do que aconteceu com o conjunto universo do dados, a amostra foi exibida como foi demonstrada na Figura 6.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{6}
\caption{Visualização dos dados no Gephi}
\label{fig:figure6}
\end{figure}

Devido a massiva quantidade de dados e a falta de aplicação de algum algoritimo de espacialização, os nós e arestas aparecem todos aglomerados. Para facilitar a visualização, aplica-se algum algoritimo de espacialização do grafo. Nessa pesquisa foi utilizado o \emph{Force Atlas 2}. O \emph{Force Atlas 2} é o algoritimo de espacialização padrão da versão utilizada nesse artigo (0.8.2). O foco desse algoritimo é transformar a rede em um mapa e possui uma variedade de técnicas para espacialização (ForceAtlas). O resultado pode ser conferido na Figura 7.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{7}
\caption{Grafo com \textit{Force Atlas 2} aplicado}
\label{fig:figure7}
\end{figure}

Além do mais, a aplicação possui outras ferramentas que auxiliam a análise e busca por padrões. Neste artigo será destacado apenas duas dessas funcionalidades: a classificação por grau do nós e a partição por modularide.

A classificação por grau funciona da seguinte forma, o software analisa qual o grau de cada nós e aplica o redimensionamento no nós de acordo com os parâmetros informados. Desta forma é possível identificar quais são os nós que mais interagem com os demais. Por meio da Figura 8 é demonstrado o resutado desse algoritimo na amostra importada.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{8}
\caption{Grafo com classificação por grau}
\label{fig:figure8}
\end{figure}

A partição por modularidade é semelhante a clusterização em mineração de dados. Na prática essa funcionalidade agrupa os nós semelhantes em cores distintas. Desta forma, o especialista no domínio dos dados consegue visualizar comunidades em seus dados e isso pode ocasionar na identificação de padrões. Na Figura 9 é exibido a amostra após aplicado o recurso de modularidade.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{9}
\caption{Grafo com partição por modularidade}
\label{fig:figure9}p
\end{figure}

\section{Conclusões}

O problema de visualização de grandes quantidades de dados em grafos descrito no seção introdutória foi resolvido conforme apresentado na seção de desenvolvimento. Primeiramente foi realizado a importação dos dados para um banco de dados em grafos cujo provê meios necessários para exportação dos dados de forma prática, apenas informando a consulta Cypher que gerará subconjuntos com amostras do conjunto universo, para um formato que pode ser lido pelo \emph{software} de visualização. No entanto, antes de gerar um subconjunto, realizou-se a exportação do banco de dados completo afim de verificar a limitação na exibição dos dados. Após constatar que não foi possível visualizar o conjunto de dados completos, exportou-se um fragmento do banco de dados no qual foi visualizado com sucesso pela aplicação de análise.

Vale salientar que esse tipo de abordagem possui algumas limitações. Se for necessário analisar todos os dados como um todo, sem poder dividí-los, essa abordagem é ineficaz. Outra possível falha é gerar uma amostra insuficiente, que pode afetar a análise dos dados.

Foi demonstrado no final da seção de desenvolvimento como algumas funcionalidades de uma aplicação de visualização de dados em grafos pode auxiliar na classificação e clusterização dos dados. Uma sugestão para um trabalho futuro seria conciliar essa abordagem com um especialista no domínio dos dados que possa validar se os padrões encontrados na visualização é relevante para área de conhecimento dos dados.

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
